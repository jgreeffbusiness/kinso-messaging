import { NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { verify } from 'jsonwebtoken';
import { prisma } from '@/server/db';
import { Prisma } from '@prisma/client';

const JWT_SECRET = process.env.JWT_SECRET || 'your-secret-key';

// Define the structure of the contact details we want to return for each part of the pair
// This should align with what your ContactUnificationService.ContactMatchScore provides
// and what the side-by-side UI will need.
export interface PotentialDuplicateContactDetail {
  id: string;
  fullName: string;
  email?: string | null;
  avatar?: string | null;
  platformSources?: string[]; // Derived from platformData
  // Add any other fields useful for UI display e.g. phone, company
}

export interface PotentialDuplicatePair {
  id: string; // ID of the PotentialDuplicate record itself
  contactA: PotentialDuplicateContactDetail;
  contactB: PotentialDuplicateContactDetail;
  reason?: string | null;
  score?: number | null;
  status: string;
  createdAt: Date;
}

// Define a type for the item returned by prisma.potentialDuplicate.findMany with includes
// This should ideally be inferred or generated by Prisma, but for now:
interface PrismaPotentialDuplicateWithIncludes extends Prisma.PotentialDuplicateGetPayload<{ 
    include: { 
        contactA: { select: { id: true, fullName: true, email: true, photoUrl: true, platformData: true } },
        contactB: { select: { id: true, fullName: true, email: true, photoUrl: true, platformData: true } }
    }
}> {}

// Helper to extract platform sources from Prisma Contact's platformData
function getPlatformSourcesFromContact(contact: { platformData?: Prisma.JsonValue | null }): string[] {
  if (contact.platformData && typeof contact.platformData === 'object' && !Array.isArray(contact.platformData)) {
    return Object.keys(contact.platformData);
  }
  return [];
}

export async function GET() {
  try {
    const cookieStore = await cookies();
    const sessionCookie = cookieStore.get('session')?.value;
    if (!sessionCookie) {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    const decoded = verify(sessionCookie, JWT_SECRET) as { userId: string };
    const userId = decoded.userId;
    if (!userId) {
      return NextResponse.json({ error: 'User ID not found' }, { status: 401 });
    }

    const pendingDuplicates = await prisma.potentialDuplicate.findMany({
      where: {
        // We need to ensure we only fetch records where this user owns *both* contacts
        // This check might be more complex if contactAId/contactBId are not directly tied to userId
        // For now, assuming the service that creates these ensures they belong to the same user context.
        // A simpler check if PotentialDuplicate itself had a userId:
        // userId: userId, 
        status: 'PENDING_REVIEW',
        contactA: { userId: userId }, // Ensure contactA belongs to the user
        contactB: { userId: userId }  // Ensure contactB belongs to the user
      },
      include: {
        contactA: { select: { id: true, fullName: true, email: true, photoUrl: true, platformData: true } },
        contactB: { select: { id: true, fullName: true, email: true, photoUrl: true, platformData: true } },
      },
      orderBy: {
        createdAt: 'desc' // Show newest potential duplicates first
      },
      take: 50 // Add pagination later if needed
    });

    const results: PotentialDuplicatePair[] = pendingDuplicates.map((pd: PrismaPotentialDuplicateWithIncludes) => ({
      id: pd.id,
      contactA: {
        id: pd.contactA.id,
        fullName: pd.contactA.fullName,
        email: pd.contactA.email,
        avatar: pd.contactA.photoUrl,
        platformSources: getPlatformSourcesFromContact(pd.contactA)
      },
      contactB: {
        id: pd.contactB.id,
        fullName: pd.contactB.fullName,
        email: pd.contactB.email,
        avatar: pd.contactB.photoUrl,
        platformSources: getPlatformSourcesFromContact(pd.contactB)
      },
      reason: pd.reason,
      score: pd.score,
      status: pd.status,
      createdAt: pd.createdAt
    }));

    return NextResponse.json({ potentialDuplicates: results });

  } catch (error: unknown) {
    const e = error as Error;
    console.error('[API /contacts/potential-duplicates] Error:', e.message);
    return NextResponse.json({ error: `Failed to fetch potential duplicates: ${e.message}` }, { status: 500 });
  }
} 